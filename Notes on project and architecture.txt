- я использую __DIR__ для загрузки файлов вместо loadFunction, т.к.:
  - я бы хотел отказаться от loadFunction
  - чтобы сделать по-нормальному, надо править php.ini. Впадлу мне смотреть
  , делают ли это возможным hostfly и прочие хостинги
  upd: вроде есть возможность в https://ultra.hostflyby.net:2083/cpsess9115743466/frontend/jupiter/multiphp_ini_editor/index.html#/editor
  , но впадлу этим заниматься - у меня есть консёрны. Уж лучше в коде будет немного говно, зато надёжнее
  upd: хотя не, буду использовать load(). В front-end папке всё равно есть необходимость в load(), т.к. иначе будте заёбка с __DIR__ внутри темплейтов -- это не хорошо.
  upd: а бля. laodFunction нельзя использовать, т.к. пропадает скоуп -- он остаётся внутри ф-ции...
  upd: ага, короче, я могу просто писать как: 'папка/папка/файл' -- т.е., в начале не должно быть никаких точек и тд. Пойдёт нахуй.

- SitePresenter::simplePage
Почему симлп? Потому что когда надо будет page по-сложнее, он уже будет называться page, и там скорее всего
уже надо будет передавать какие-нибудь данные, а не только $title

- как бы замедленно (локально) работает раутинг после call_user_func после 
  Заметил что локально бывает под 300-350ms скорость загрузки html. На проде такого нет -- там 20ms обычно.
  Наверно, связано с тем, что в деве(а дев ли это?) неоптимизирован вызов этой ф-ции, в отличие от настроек на проде.

Скорости загрузки на проде as of 2025-07-13 15:30 (уже есть загружаемые частички данных, кэша нету):
112ms (редко), 26ms (обычно).
2025-07-30 21:01: поменял сегодня структуру проекта немного - грамотнее переписал раутинг в плане методов, теперь используется автолоадинг классов где нужно.
Скорость осталась либо та же, либо стала чуть быстрее на несколько миллисекунд. Хотя при одном из первоначальных запусков скорость была 356ms, но потом всё стало быстро, как и прежде.

- why .htacccess
Он нужен, чтобы при загрузке на какой-нибудь хостинг сразу поддерживался правильный раутинг.

- Поиск
Когда в базе меняем hidden или is_deleted, надо вручную пересоздавать поиск, т.к. иначе изменения в видимости не отобразятся - данные будут старыми.
Например, админ удалил товар из базы и решил его восстановить. Программист восстанавливает, устанавливая 0 в is_deleted. Но поиск не отобразит этот товар, т.к. данные
берутся из галимого джейсона, а не из sqlite.
Хотя по идее можно сделать и как-то так: в нужном товаре два раза нажать на кнопку "Скрыть" - таким образом код по обновлению поиска сработает.

- check to see if there any diffs in incoming new price list and current products in db
Put this in DataUpdater->updatePrice() somewhere on line 71:
$dbArts = $this->repository->query("SELECT art FROM products")->fetchAll(PDO::FETCH_COLUMN);
$diff = array_diff($fileArts, $dbArts);
var_dump($diff);
die();

And to check if everything's fine before really updating the data, put this code somewhere also after line 71 (note the commenting of the UPDATE):
$differentPs = [];
foreach ($excelProducts as $p) {
  $dbP = $this->repository->query("SELECT * from products WHERE art = '{$p['art']}'")->fetch();
  if (!($dbP['price'] == $p['price'] && $dbP['variant'] == $p['variant'] && $dbP['unit'] == $p['unit'] && $dbP['upakMal'] == $p['upakMal'] && $dbP['upakKrup'] == $p['upakKrup'])) {
    $differentPs[] = $p;
  }

  // $this->repository->exec("UPDATE products SET price = '{$p['price']}', variant = '{$p['variant']}', unit = '{$p['unit']}', upakMal = '{$p['upakMal']}', upakKrup = '{$p['upakMal']}' WHERE art = '{$p['art']}'");
}
var_dump($differentPs);
die();